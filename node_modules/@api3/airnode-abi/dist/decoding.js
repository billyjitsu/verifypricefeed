"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = void 0;
const ethers_1 = require("ethers");
const chunk_1 = __importDefault(require("lodash/chunk"));
const constants_1 = require("./constants");
// Certain types need to be parsed after ABI decoding happens
const VALUE_TRANSFORMATIONS = {
    string32: ethers_1.ethers.utils.parseBytes32String,
    int256: (value) => value.toString(),
    uint256: (value) => value.toString(),
};
function buildDecodedMap(types, nameValuePairs) {
    return nameValuePairs.reduce((acc, pair, index) => {
        const [encodedName, encodedValue] = pair;
        const name = ethers_1.ethers.utils.parseBytes32String(encodedName);
        const type = types[index];
        const transform = VALUE_TRANSFORMATIONS[type];
        // If the type does not need to be transformed, return it as is
        if (!transform) {
            return { ...acc, [name]: encodedValue };
        }
        const parsedValue = transform(encodedValue);
        return { ...acc, [name]: parsedValue };
    }, {});
}
function decode(encodedData) {
    // Special cases for empty parameters
    if (encodedData === '0x') {
        return {};
    }
    // Alternatively:
    // const header = encodedData.substring(0, 66);
    const header = ethers_1.ethers.utils.hexlify(ethers_1.ethers.utils.arrayify(encodedData).slice(0, 32));
    const parsedHeader = ethers_1.ethers.utils.parseBytes32String(header);
    // Get and validate the first character of the header
    const encodedEncodingVersion = parsedHeader.substring(0, 1);
    if (encodedEncodingVersion !== '1') {
        throw new Error(`Unknown ABI schema version: ${encodedEncodingVersion}`);
    }
    // The version is specified by the first byte and the parameters are specified by the rest
    const encodedParameterTypes = parsedHeader.substring(1);
    // Replace encoded types with full type names
    const fullParameterTypes = Array.from(encodedParameterTypes).map((type) => constants_1.PARAMETER_SHORT_TYPES[type]);
    // The first `bytes32` is the type encoding
    const initialDecodedTypes = ['bytes32'];
    const decodingTypes = fullParameterTypes.reduce((acc, type) => {
        // Each parameter is expected to have a `bytes32` name
        return [...acc, 'bytes32', constants_1.TYPE_TRANSFORMATIONS[type] ?? type];
    }, initialDecodedTypes);
    // It's important to leave the `encodedData` intact here and not try to trim off the first
    // 32 bytes (i.e. the header) because that results in the decoding failing. So decode
    // exactly what you got from the contract, including the header.
    const decodedData = ethers_1.ethers.utils.defaultAbiCoder.decode(decodingTypes, encodedData);
    // Checks if the original encoded data matches the re-encoded data
    const reEncodedData = ethers_1.ethers.utils.defaultAbiCoder.encode(decodingTypes, decodedData);
    if (reEncodedData !== encodedData) {
        throw new Error('Re-encoding mismatch');
    }
    const [_version, ...decodedParameters] = decodedData;
    const nameValuePairs = (0, chunk_1.default)(decodedParameters, 2);
    return buildDecodedMap(fullParameterTypes, nameValuePairs);
}
exports.decode = decode;
//# sourceMappingURL=decoding.js.map